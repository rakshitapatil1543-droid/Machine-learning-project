# -*- coding: utf-8 -*-
"""NETFLIX

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1P8nMs-iqbnRUAq3ZB8399xjE9kquWPE5
"""

#importing lib.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

df=pd.read_csv('mymoviedb.csv',lineterminator='\n')
df.head()

#viewing dataset info
df.info()

#exploring genres coloun
df['Genre'].head()

# check for duplicated rpws
df.duplicated().sum()

#exploring summary statistics
df.describe()

# casting column a
df["Release_Date"] = pd.to_datetime(df["Release_Date"])
print(df)

df['Release_Date'] = pd.to_datetime(df['Release_Date'])
df['only_Date'] = df['Release_Date'].dt.date
df['Year'] = df['Release_Date'].dt.year
df['Year'].dtypes

#Dropping Overview, Original_Langauage and Poster-Url
# marking List og column to be dropped
cols = ['Overview','Original_Language','Poster_Url']
df.drop(cols,axis = 1, inplace = True)
df.columns

df.head()

def catigorize_col(df,col,labels):
  # setting the edges to cut the column accordingly
  edges =[
      df[col].describe()['min'],
      df[col].describe()['25%'],
      df[col].describe()['50%'],
      df[col].describe()['75%'],
      df[col].describe()['max']
  ]

  # cut the column into categories
  df[col] = pd.cut(df[col], bins=edges, labels=labels, duplicates='drop')

  return df

labels = ['not_popular','below_avg','average','popular']
df=catigorize_col(df, 'Vote_Average',labels)
print(df['Vote_Average'].unique())

#exploring column
df['Vote_Average'].value_counts()

#dropping NaNs
df.dropna(inplace=True)
#confirming
df.isna().sum()

df.head()

#split the strings into lists
df['Genre'] = df['Genre'].str.split(',')
#Explode the lists
df=df.explode('Genre').reset_index(drop=True)
df.head()

#casting column into category
df['Genre']=df['Genre'].astype('category')
#confirming changes
df['Genre'].dtypes

df.info()

df.nunique()

#-------Data visualization--------

#setting up seaborn configurations
sns.set_style('whitegrid')

#Q1:What is the most frequent genre in the dataset?
#showing stats.on genre column
df['Genre'].describe()

#Visualizing the Genre column distribution
sns.catplot(y='Genre',data=df,kind='count',
    order=df['Genre'].value_counts().index,
    color='#4287f5')
plt.title('Genre column Distribution')
plt.show()

#Q2:What genres has highest votes?
#visualizing the vote_Average coiumn distribution
sns.catplot(
    y='Vote_Average',
    data=df,
    kind='count',
    order=df['Vote_Average'].value_counts().index,
    color='#4287f5'
)

plt.title('Vote_Average column Distribution')
plt.show()

#Q3:What movie got the highest genre?
#checking max popularity in dataset
df[df['Popularity'] ==df['Popularity'].max()]

#Q3:What movie got the highest genre?
#checking max popularity in dataset
df[df['Popularity'] ==df['Popularity'].min()]

#Q5: Which year has the most filmmed movies?
df['Release_Date'].hist()
plt.title('Release_Date column distrubution')
plt.show()

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import confusion_matrix, classification_report

le = LabelEncoder()
df['Vote_Average_Enc'] = le.fit_transform(df['Vote_Average'])

X = df[['Popularity', 'Vote_Count']]
y = df['Vote_Average_Enc']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

model = LogisticRegression(max_iter=1000)
model.fit(X_train, y_train)

y_pred = model.predict(X_test)

plt.figure(figsize=(6,4))
sns.heatmap(df[['Popularity', 'Vote_Count', 'Year']].corr(),annot=True, cmap='coolwarm')
plt.title("Correlation Heatmap")
plt.show()

plt.figure(figsize=(6,4))
sns.scatterplot(
    x='Popularity',
    y='Vote_Count',
    hue='Vote_Average',
    data=df,
    alpha=0.6
)
plt.title("Popularity vs Vote Count")
plt.show()


cm = confusion_matrix(y_test, y_pred)

plt.figure(figsize=(6,4))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues')
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.title("Confusion Matrix")
plt.show()
print(classification_report(y_test, y_pred))